package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83 DO NOT EDIT.

import (
	"context"
	"fmt"

	"github.com/kota/distributed-system-sample/bff/graph/model"
	postpb "github.com/kota/distributed-system-sample/post-service/proto/post"
	userpb "github.com/kota/distributed-system-sample/user-service/proto/user"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	res, err := r.UserClient.CreateUser(ctx, &userpb.CreateUserRequest{
		Name:  input.Name,
		Email: input.Email,
	})
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:    res.Id,
		Name:  res.Name,
		Email: res.Email,
	}, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPost) (*model.Post, error) {
	res, err := r.PostClient.CreatePost(ctx, &postpb.CreatePostRequest{
		Title:   input.Title,
		Content: input.Content,
		UserId:  input.UserID,
	})
	if err != nil {
		return nil, err
	}
	// Note: We need to fetch the user to populate the User field in Post, 
	// but for simple creation response, we might defer it or fetch it here.
	// For now, let's just return the post and let the User resolver handle the user field if requested.
	// However, the return type is *model.Post which has User *model.User.
	// So we should probably fetch the user or construct a partial user.
	// Let's fetch the user to be safe and correct.
	
	userRes, err := r.UserClient.GetUser(ctx, &userpb.GetUserRequest{Id: input.UserID})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user for post: %w", err)
	}

	return &model.Post{
		ID:      res.Id,
		Title:   res.Title,
		Content: res.Content,
		User: &model.User{
			ID:    userRes.Id,
			Name:  userRes.Name,
			Email: userRes.Email,
		},
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	res, err := r.UserClient.ListUsers(ctx, &userpb.ListUsersRequest{})
	if err != nil {
		return nil, err
	}
	var users []*model.User
	for _, u := range res.Users {
		users = append(users, &model.User{
			ID:    u.Id,
			Name:  u.Name,
			Email: u.Email,
		})
	}
	return users, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	res, err := r.UserClient.GetUser(ctx, &userpb.GetUserRequest{Id: id})
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:    res.Id,
		Name:  res.Name,
		Email: res.Email,
	}, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	res, err := r.PostClient.ListPosts(ctx, &postpb.ListPostsRequest{})
	if err != nil {
		return nil, err
	}
	var posts []*model.Post
	for _, p := range res.Posts {
		// We need to resolve the User for each post.
		// This is the N+1 problem. For simplicity, we will fetch user one by one here, 
		// or better, let the PostResolver handle it?
		// The schema has Post.user. 
		// If we return model.Post without User, and have a PostResolver, it would be better.
		// But currently model.Post struct has User field.
		// If we want to use a PostResolver, we need to change the model or configuration.
		// For this simple task, I'll just fetch the user here (N+1).
		// Optimization can be done later with Dataloaders.
		
		userRes, err := r.UserClient.GetUser(ctx, &userpb.GetUserRequest{Id: p.UserId})
		if err != nil {
			// If user not found, maybe just log or ignore? 
			// For now, fail.
			return nil, fmt.Errorf("failed to fetch user %s for post %s: %w", p.UserId, p.Id, err)
		}

		posts = append(posts, &model.Post{
			ID:      p.Id,
			Title:   p.Title,
			Content: p.Content,
			User: &model.User{
				ID:    userRes.Id,
				Name:  userRes.Name,
				Email: userRes.Email,
			},
		})
	}
	return posts, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	res, err := r.PostClient.GetPost(ctx, &postpb.GetPostRequest{Id: id})
	if err != nil {
		return nil, err
	}
	
	userRes, err := r.UserClient.GetUser(ctx, &userpb.GetUserRequest{Id: res.UserId})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user for post: %w", err)
	}

	return &model.Post{
		ID:      res.Id,
		Title:   res.Title,
		Content: res.Content,
		User: &model.User{
			ID:    userRes.Id,
			Name:  userRes.Name,
			Email: userRes.Email,
		},
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
